server:
  port: 9099

#  servlet:
#    context-path: /api/managerService     # 接口请求前缀配置

spring:
  application:
     name: managerService1
  profiles:
      active: loc
  datasource:
      url: jdbc:mysql://121.41.1.176:3306/fish_blog?useUnicode=true&characterEncoding=utf-8&useSSL=true&serverTimezone=Asia/Shanghai
      username: root
      password: KtEEtf7qrX7e!
      driver-class-name: com.mysql.cj.jdbc.Driver
      type: com.alibaba.druid.pool.DruidDataSource
      druid:
         max-active: 10
         initialSize: 1
         maxWait: 60000
         minIdle: 1
         timeBetweenEvictionRunsMillis: 60000
         minEvictableIdleTimeMillis: 300000
         validationQuery: select 'x'
         testWhileIdle: true
         testOnBorrow: false
         testOnReturn: false
         poolPreparedStatements: true
         maxOpenPreparedStatements: 20
         filters: stat,wall,slf4j
  main:
    allow-bean-definition-overriding: true
  servlet:
    multipart:
      enabled: true
      max-request-size: 50MB
      max-file-size: 50MB

  redis:
    host: 121.41.1.176
    port: 6379
    database: 1
    timeout: 5000
    password: ruiyun12345
    lettuce:
      pool:
        max-active: 8
        max-wait: -1
        max-idle: 8
        min-idle: 0
#      shutdown-timeout: 200                           #在关闭客户端连接之前等待任务处理完成的最长时间，在这之后，无论任务是否执行完成，都会被执行器关闭，默认100ms

# 健康监控
management:
  endpoints:
    web:
      exposure:
        #暴露所有端点
        include: "*"
  endpoint:
    health:
      show-details: always

eureka:
  instance:
    prefer-ip-address: true
    instance-id: ${spring.cloud.client.ip-address}:${server.port}
    lease-renewal-interval-in-seconds: 5         #默认是30s 表示eureka client发送心跳给server端的频率。如果在leaseExpirationDurationInSeconds后，server端没有收到client的心跳，则将摘除该instance
    lease-expiration-duration-in-seconds: 10     #默认是90s 表示eureka server至上一次收到client的心跳之后，等待下一次心跳的超时时间，在这个时间内若没收到下一次心跳，则将移除该instance

  client:
    register-with-eureka: true
    serviceUrl:
      defaultZone: http://127.0.0.1:8081/eureka/

ribbon:
  #指的是建立连接所用的时间，适用于网络状况正常的情况下，两端连接所用的实际
  ReadTimeout: 5000
  #指的是建立连接后从服务器读取到可用资源所用的时间
  ConnectTimeout: 5000

feign:
  hystrix:
    enabled: true    #开始熔断

#配置openFeign负载策略不配置的话默认使用ribbon进行负载均衡
stu-provide:
  ribbon:
    #NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule #随机
    #NFLoadBalancerRuleClassName: com.netflix.loadbalancer.BestAvailableRule #最空闲连接策略
    #NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule #轮询
    #NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RetryRule #重试
    #NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule #响应时间权重
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.BestAvailableRule #最空闲连接策略
    ConnectTimeout: 10000 #请求连接超时时间
    ReadTimeout: 11000 #请求处理的超时时间
    OkToRetryOnAllOperations: false #对所有请求都进行重试
    MaxAutoRetriesNextServer: 2 #切换实例的重试次数
    MaxAutoRetries: 1 #对当前实例的重试次数

hystrix:
  command:
    default:
      execution:
        timeout:
          enabled: true      #如果enabled设置为false，则请求超时交给ribbon控制,为true,则超时作为熔断根据
        isolation:
          thread:
            timeoutInMilliseconds: 500000 #断路器超时时间，默认1000ms

knife4j:
  enable: true

